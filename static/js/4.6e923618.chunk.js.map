{"version":3,"sources":["../node_modules/swr/esm/libs/is-document-visible.js","../node_modules/swr/esm/libs/is-online.js","../node_modules/swr/esm/libs/hash.js","../node_modules/swr/esm/cache.js","../node_modules/swr/esm/config.js","../node_modules/swr/esm/libs/throttle.js","../node_modules/swr/esm/swr-config-context.js","../node_modules/swr/esm/use-swr.js","../node_modules/swr/esm/use-swr-pages.js","../node_modules/swr/esm/index.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../node_modules/swr/node_modules/fast-deep-equal/index.js","../node_modules/react-use/esm/useSessionStorage.js","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/types/types-internal.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/immer.ts","../../src/utils/env.ts"],"names":["isDocumentVisible","document","visibilityState","isOnline","navigator","onLine","table","WeakMap","counter","cache","Cache","initialData","this","__cache","Map","Object","entries","__listeners","prototype","get","key","_key","serializeKey","set","value","shouldNotify","mutate","notify","keys","Array","from","has","clear","forEach","delete","args","err","isArray","length","i","_hash","String","hash","subscribe","listener","_this","Error","isSubscribed","push","index","indexOf","_i","_a","CONCURRENT_PROMISES","CONCURRENT_PROMISES_TS","FOCUS_REVALIDATORS","CACHE_REVALIDATORS","MUTATION_TS","slowConnection","window","effectiveType","defaultConfig","onLoadingSlow","onSuccess","onError","onErrorRetry","_","__","config","revalidate","opts","errorRetryCount","retryCount","count","Math","min","timeout","random","errorRetryInterval","setTimeout","focusThrottleInterval","dedupingInterval","loadingTimeout","refreshInterval","revalidateOnFocus","revalidateOnReconnect","refreshWhenHidden","refreshWhenOffline","shouldRetryOnError","suspense","compare","deepEqual","eventsBinded","addEventListener","throttle","fn","interval","pending","arguments","apply","SWRConfigContext","createContext","displayName","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","done","then","__generator","body","f","y","t","g","label","sent","trys","ops","verb","Symbol","iterator","n","v","op","TypeError","call","pop","IS_SERVER","useIsomorphicLayoutEffect","useEffect","useLayoutEffect","trigger","shouldRevalidate","keyErr","updaters","currentData","currentError","promises","all","broadcastState","data","error","_data","beforeMutationTs","beforeConcurrentPromisesTs","err_1","err_2","Date","now","Provider","useSWR","fnArgs","assign","useContext","fetcher","initialError","stateDependencies","useRef","isValidating","stateRef","rerender","useState","dispatch","useCallback","payload","shouldUpdateState","k","current","unmountedRef","keyRef","eventsRef","emit","event","params","boundMutate","revalidateOpts","loading","shouldDeduping","newData","startAt","newState","err_3","dedupe","undefined","currentHookData","latestKeyedData","onFocus","softRevalidate","revalidateOnMount","onUpdate","updatedData","updatedError","needUpdate","reconnect","revalidators","removeEventListener","timer","tick","clearTimeout","latestData","latestError","useMemo","state","defineProperties","enumerable","ownKeys","object","enumerableOnly","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread2","target","source","getOwnPropertyDescriptors","defineProperty","keyList","hasProp","hasOwnProperty","module","exports","equal","a","b","arrA","arrB","dateA","dateB","getTime","regexpA","RegExp","regexpB","toString","useSessionStorage","initialValue","raw","isClient","sessionStorageValue","sessionStorage","getItem","setItem","JSON","stringify","parse","setState","serializedState","die","msg","join","isDraft","DRAFT_STATE","isDraftable","proto","getPrototypeOf","DRAFTABLE","constructor","isMap","isSet","each","obj","iter","getArchtype","entry","thing","type_","prop","propOrOldValue","add","is","x","hasMap","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","desc","writable","configurable","create","freeze","deep","isFrozen","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","autoFreeze_","peek","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","currentImpl","copy","archType","hasChanges_","copyHelper","hasSymbol","hasProxies","Reflect","getOwnPropertyNames","deleteProperty","owner","setPrototypeOf","useProxies","setUseProxies","autoFreeze","setAutoFreeze","produce","bind","produceWithPatches","recipe","defaultBase","self","hasError","arg1","arg2","patches","inversePatches","_this2","p","ip","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_"],"mappings":"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","file":"static/js/4.6e923618.chunk.js","sourcesContent":["export default function isDocumentVisible() {\n    if (typeof document !== 'undefined' &&\n        typeof document.visibilityState !== 'undefined') {\n        return document.visibilityState !== 'hidden';\n    }\n    // always assume it's visible\n    return true;\n}\n","export default function isOnline() {\n    if (typeof navigator.onLine !== 'undefined') {\n        return navigator.onLine;\n    }\n    // always assume it's online\n    return true;\n}\n","// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nvar table = new WeakMap();\n// counter of the key\nvar counter = 0;\n// hashes an array of objects and returns a string\nexport default function hash(args) {\n    if (!args.length)\n        return '';\n    var key = 'arg';\n    for (var i = 0; i < args.length; ++i) {\n        var _hash = void 0;\n        if (args[i] === null || typeof args[i] !== 'object') {\n            // need to consider the case that args[i] is a string:\n            // args[i]        _hash\n            // \"undefined\" -> '\"undefined\"'\n            // undefined   -> 'undefined'\n            // 123         -> '123'\n            // null        -> 'null'\n            // \"null\"      -> '\"null\"'\n            if (typeof args[i] === 'string') {\n                _hash = '\"' + args[i] + '\"';\n            }\n            else {\n                _hash = String(args[i]);\n            }\n        }\n        else {\n            if (!table.has(args[i])) {\n                _hash = counter;\n                table.set(args[i], counter++);\n            }\n            else {\n                _hash = table.get(args[i]);\n            }\n        }\n        key += '@' + _hash;\n    }\n    return key;\n}\n","import { mutate } from './use-swr';\nimport hash from './libs/hash';\nvar Cache = /** @class */ (function () {\n    function Cache(initialData) {\n        if (initialData === void 0) { initialData = {}; }\n        this.__cache = new Map(Object.entries(initialData));\n        this.__listeners = [];\n    }\n    Cache.prototype.get = function (key) {\n        var _key = this.serializeKey(key)[0];\n        return this.__cache.get(_key);\n    };\n    Cache.prototype.set = function (key, value, shouldNotify) {\n        if (shouldNotify === void 0) { shouldNotify = true; }\n        var _key = this.serializeKey(key)[0];\n        this.__cache.set(_key, value);\n        if (shouldNotify)\n            mutate(key, value, false);\n        this.notify();\n    };\n    Cache.prototype.keys = function () {\n        return Array.from(this.__cache.keys());\n    };\n    Cache.prototype.has = function (key) {\n        var _key = this.serializeKey(key)[0];\n        return this.__cache.has(_key);\n    };\n    Cache.prototype.clear = function (shouldNotify) {\n        if (shouldNotify === void 0) { shouldNotify = true; }\n        if (shouldNotify)\n            this.__cache.forEach(function (key) { return mutate(key, null, false); });\n        this.__cache.clear();\n        this.notify();\n    };\n    Cache.prototype.delete = function (key, shouldNotify) {\n        if (shouldNotify === void 0) { shouldNotify = true; }\n        var _key = this.serializeKey(key)[0];\n        if (shouldNotify)\n            mutate(key, null, false);\n        this.__cache.delete(_key);\n        this.notify();\n    };\n    // TODO: introduce namespace for the cache\n    Cache.prototype.serializeKey = function (key) {\n        var args = null;\n        if (typeof key === 'function') {\n            try {\n                key = key();\n            }\n            catch (err) {\n                // dependencies not ready\n                key = '';\n            }\n        }\n        if (Array.isArray(key)) {\n            // args array\n            args = key;\n            key = hash(key);\n        }\n        else {\n            // convert null to ''\n            key = String(key || '');\n        }\n        var errorKey = key ? 'err@' + key : '';\n        return [key, args, errorKey];\n    };\n    Cache.prototype.subscribe = function (listener) {\n        var _this = this;\n        if (typeof listener !== 'function') {\n            throw new Error('Expected the listener to be a function.');\n        }\n        var isSubscribed = true;\n        this.__listeners.push(listener);\n        return function () {\n            if (!isSubscribed)\n                return;\n            isSubscribed = false;\n            var index = _this.__listeners.indexOf(listener);\n            if (index > -1) {\n                _this.__listeners[index] = _this.__listeners[_this.__listeners.length - 1];\n                _this.__listeners.length--;\n            }\n        };\n    };\n    // Notify Cache subscribers about a change in the cache\n    Cache.prototype.notify = function () {\n        for (var _i = 0, _a = this.__listeners; _i < _a.length; _i++) {\n            var listener = _a[_i];\n            listener();\n        }\n    };\n    return Cache;\n}());\nexport default Cache;\n","import deepEqual from 'fast-deep-equal';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport Cache from './cache';\n// cache\nvar cache = new Cache();\n// state managers\nvar CONCURRENT_PROMISES = {};\nvar CONCURRENT_PROMISES_TS = {};\nvar FOCUS_REVALIDATORS = {};\nvar CACHE_REVALIDATORS = {};\nvar MUTATION_TS = {};\n// error retry\nfunction onErrorRetry(_, __, config, revalidate, opts) {\n    if (!isDocumentVisible()) {\n        // if it's hidden, stop\n        // it will auto revalidate when focus\n        return;\n    }\n    if (config.errorRetryCount && opts.retryCount > config.errorRetryCount) {\n        return;\n    }\n    // exponential backoff\n    var count = Math.min(opts.retryCount || 0, 8);\n    var timeout = ~~((Math.random() + 0.5) * (1 << count)) * config.errorRetryInterval;\n    setTimeout(revalidate, timeout, opts);\n}\n// client side: need to adjust the config\n// based on the browser status\n// slow connection (<= 70Kbps)\nvar slowConnection = typeof window !== 'undefined' &&\n    navigator['connection'] &&\n    ['slow-2g', '2g'].indexOf(navigator['connection'].effectiveType) !== -1;\n// config\nvar defaultConfig = {\n    // events\n    onLoadingSlow: function () { },\n    onSuccess: function () { },\n    onError: function () { },\n    onErrorRetry: onErrorRetry,\n    errorRetryInterval: (slowConnection ? 10 : 5) * 1000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: (slowConnection ? 5 : 3) * 1000,\n    refreshInterval: 0,\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    refreshWhenHidden: false,\n    refreshWhenOffline: false,\n    shouldRetryOnError: true,\n    suspense: false,\n    compare: deepEqual\n};\n// Focus revalidate\nvar eventsBinded = false;\nif (typeof window !== 'undefined' && window.addEventListener && !eventsBinded) {\n    var revalidate = function () {\n        if (!isDocumentVisible() || !isOnline())\n            return;\n        for (var key in FOCUS_REVALIDATORS) {\n            if (FOCUS_REVALIDATORS[key][0])\n                FOCUS_REVALIDATORS[key][0]();\n        }\n    };\n    window.addEventListener('visibilitychange', revalidate, false);\n    window.addEventListener('focus', revalidate, false);\n    // only bind the events once\n    eventsBinded = true;\n}\nexport { CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, CACHE_REVALIDATORS, MUTATION_TS, cache };\nexport default defaultConfig;\n","export default function throttle(fn, interval) {\n    var pending = false;\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (pending)\n            return;\n        pending = true;\n        fn.apply(void 0, args);\n        setTimeout(function () { return (pending = false); }, interval);\n    };\n}\n","import { createContext } from 'react';\nvar SWRConfigContext = createContext({});\nSWRConfigContext.displayName = 'SWRConfigContext';\nexport default SWRConfigContext;\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { useCallback, useContext, useEffect, useLayoutEffect, useState, useRef, useMemo } from 'react';\nimport defaultConfig, { CACHE_REVALIDATORS, CONCURRENT_PROMISES, CONCURRENT_PROMISES_TS, FOCUS_REVALIDATORS, MUTATION_TS, cache } from './config';\nimport isDocumentVisible from './libs/is-document-visible';\nimport isOnline from './libs/is-online';\nimport throttle from './libs/throttle';\nimport SWRConfigContext from './swr-config-context';\nvar IS_SERVER = typeof window === 'undefined';\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nvar useIsomorphicLayoutEffect = IS_SERVER ? useEffect : useLayoutEffect;\nvar trigger = function (_key, shouldRevalidate) {\n    if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n    // we are ignoring the second argument which correspond to the arguments\n    // the fetcher will receive when key is an array\n    var _a = cache.serializeKey(_key), key = _a[0], keyErr = _a[2];\n    if (!key)\n        return Promise.resolve();\n    var updaters = CACHE_REVALIDATORS[key];\n    if (key && updaters) {\n        var currentData = cache.get(key);\n        var currentError = cache.get(keyErr);\n        var promises = [];\n        for (var i = 0; i < updaters.length; ++i) {\n            promises.push(updaters[i](shouldRevalidate, currentData, currentError, i > 0));\n        }\n        // return new updated value\n        return Promise.all(promises).then(function () { return cache.get(key); });\n    }\n    return Promise.resolve(cache.get(key));\n};\nvar broadcastState = function (key, data, error) {\n    var updaters = CACHE_REVALIDATORS[key];\n    if (key && updaters) {\n        for (var i = 0; i < updaters.length; ++i) {\n            updaters[i](false, data, error);\n        }\n    }\n};\nvar mutate = function (_key, _data, shouldRevalidate) {\n    if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n    return __awaiter(void 0, void 0, void 0, function () {\n        var key, data, error, beforeMutationTs, beforeConcurrentPromisesTs, err_1, err_2, updaters, promises, i;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    key = cache.serializeKey(_key)[0];\n                    if (!key)\n                        return [2 /*return*/];\n                    // if there is no new data, call revalidate against the key\n                    if (typeof _data === 'undefined')\n                        return [2 /*return*/, trigger(_key, shouldRevalidate)\n                            // update timestamp\n                        ];\n                    // update timestamp\n                    MUTATION_TS[key] = Date.now() - 1;\n                    beforeMutationTs = MUTATION_TS[key];\n                    beforeConcurrentPromisesTs = CONCURRENT_PROMISES_TS[key];\n                    if (!(_data && typeof _data === 'function')) return [3 /*break*/, 5];\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, _data(cache.get(key))];\n                case 2:\n                    data = _a.sent();\n                    return [3 /*break*/, 4];\n                case 3:\n                    err_1 = _a.sent();\n                    error = err_1;\n                    return [3 /*break*/, 4];\n                case 4: return [3 /*break*/, 11];\n                case 5:\n                    if (!(_data && typeof _data.then === 'function')) return [3 /*break*/, 10];\n                    _a.label = 6;\n                case 6:\n                    _a.trys.push([6, 8, , 9]);\n                    return [4 /*yield*/, _data];\n                case 7:\n                    data = _a.sent();\n                    return [3 /*break*/, 9];\n                case 8:\n                    err_2 = _a.sent();\n                    error = err_2;\n                    return [3 /*break*/, 9];\n                case 9: return [3 /*break*/, 11];\n                case 10:\n                    data = _data;\n                    _a.label = 11;\n                case 11:\n                    // Check if other mutations have occurred since we've started awaiting, if so then do not persist this change\n                    if (beforeMutationTs !== MUTATION_TS[key] ||\n                        beforeConcurrentPromisesTs !== CONCURRENT_PROMISES_TS[key]) {\n                        if (error)\n                            throw error;\n                        return [2 /*return*/, data];\n                    }\n                    if (typeof data !== 'undefined') {\n                        // update cached data, avoid notifying from the cache\n                        cache.set(key, data, false);\n                    }\n                    updaters = CACHE_REVALIDATORS[key];\n                    if (updaters) {\n                        promises = [];\n                        for (i = 0; i < updaters.length; ++i) {\n                            promises.push(updaters[i](!!shouldRevalidate, data, error, i > 0));\n                        }\n                        // return new updated value\n                        return [2 /*return*/, Promise.all(promises).then(function () { return cache.get(key); })];\n                    }\n                    // throw error or return data to be used by caller of mutate\n                    if (error)\n                        throw error;\n                    return [2 /*return*/, data];\n            }\n        });\n    });\n};\nfunction useSWR() {\n    var _this = this;\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var _key, fn, config = {};\n    if (args.length >= 1) {\n        _key = args[0];\n    }\n    if (args.length > 2) {\n        fn = args[1];\n        config = args[2];\n    }\n    else {\n        if (typeof args[1] === 'function') {\n            fn = args[1];\n        }\n        else if (typeof args[1] === 'object') {\n            config = args[1];\n        }\n    }\n    // we assume `key` as the identifier of the request\n    // `key` can change but `fn` shouldn't\n    // (because `revalidate` only depends on `key`)\n    // `keyErr` is the cache key for error objects\n    var _a = cache.serializeKey(_key), key = _a[0], fnArgs = _a[1], keyErr = _a[2];\n    config = Object.assign({}, defaultConfig, useContext(SWRConfigContext), config);\n    if (typeof fn === 'undefined') {\n        // use a global fetcher\n        fn = config.fetcher;\n    }\n    var initialData = cache.get(key) || config.initialData;\n    var initialError = cache.get(keyErr);\n    // if a state is accessed (data, error or isValidating),\n    // we add the state to dependencies so if the state is\n    // updated in the future, we can trigger a rerender\n    var stateDependencies = useRef({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    var stateRef = useRef({\n        data: initialData,\n        error: initialError,\n        isValidating: false\n    });\n    var rerender = useState(null)[1];\n    var dispatch = useCallback(function (payload) {\n        var shouldUpdateState = false;\n        for (var k in payload) {\n            stateRef.current[k] = payload[k];\n            if (stateDependencies.current[k]) {\n                shouldUpdateState = true;\n            }\n        }\n        if (shouldUpdateState || config.suspense) {\n            rerender({});\n        }\n    }, []);\n    // error ref inside revalidate (is last request errored?)\n    var unmountedRef = useRef(false);\n    var keyRef = useRef(key);\n    // do unmount check for callbacks\n    var eventsRef = useRef({\n        emit: function (event) {\n            var params = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                params[_i - 1] = arguments[_i];\n            }\n            if (unmountedRef.current)\n                return;\n            config[event].apply(config, params);\n        }\n    });\n    var boundMutate = useCallback(function (data, shouldRevalidate) {\n        return mutate(key, data, shouldRevalidate);\n    }, [key]);\n    // start a revalidation\n    var revalidate = useCallback(function (revalidateOpts) {\n        if (revalidateOpts === void 0) { revalidateOpts = {}; }\n        return __awaiter(_this, void 0, void 0, function () {\n            var loading, shouldDeduping, newData, startAt, newState, err_3, retryCount;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!key || !fn)\n                            return [2 /*return*/, false];\n                        if (unmountedRef.current)\n                            return [2 /*return*/, false];\n                        revalidateOpts = Object.assign({ dedupe: false }, revalidateOpts);\n                        loading = true;\n                        shouldDeduping = typeof CONCURRENT_PROMISES[key] !== 'undefined' && revalidateOpts.dedupe;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 6, , 7]);\n                        dispatch({\n                            isValidating: true\n                        });\n                        newData = void 0;\n                        startAt = void 0;\n                        if (!shouldDeduping) return [3 /*break*/, 3];\n                        // there's already an ongoing request,\n                        // this one needs to be deduplicated.\n                        startAt = CONCURRENT_PROMISES_TS[key];\n                        return [4 /*yield*/, CONCURRENT_PROMISES[key]];\n                    case 2:\n                        newData = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 3:\n                        // if not deduping the request (hard revalidate) but\n                        // there're other ongoing request(s) at the same time,\n                        // we need to ignore the other result(s) to avoid\n                        // possible race conditions:\n                        // req1------------------>res1\n                        //      req2-------->res2\n                        // in that case, the second response should not be overridden\n                        // by the first one.\n                        if (CONCURRENT_PROMISES[key]) {\n                            // we can mark it as a mutation to ignore\n                            // all requests which are fired before this one\n                            MUTATION_TS[key] = Date.now() - 1;\n                        }\n                        // if no cache being rendered currently (it shows a blank page),\n                        // we trigger the loading slow event.\n                        if (config.loadingTimeout && !cache.get(key)) {\n                            setTimeout(function () {\n                                if (loading)\n                                    eventsRef.current.emit('onLoadingSlow', key, config);\n                            }, config.loadingTimeout);\n                        }\n                        if (fnArgs !== null) {\n                            CONCURRENT_PROMISES[key] = fn.apply(void 0, fnArgs);\n                        }\n                        else {\n                            CONCURRENT_PROMISES[key] = fn(key);\n                        }\n                        CONCURRENT_PROMISES_TS[key] = startAt = Date.now();\n                        return [4 /*yield*/, CONCURRENT_PROMISES[key]];\n                    case 4:\n                        newData = _a.sent();\n                        setTimeout(function () {\n                            delete CONCURRENT_PROMISES[key];\n                            delete CONCURRENT_PROMISES_TS[key];\n                        }, config.dedupingInterval);\n                        // trigger the success event,\n                        // only do this for the original request.\n                        eventsRef.current.emit('onSuccess', newData, key, config);\n                        _a.label = 5;\n                    case 5:\n                        // if the revalidation happened earlier than the local mutation,\n                        // we have to ignore the result because it could override.\n                        // meanwhile, a new revalidation should be triggered by the mutation.\n                        if (MUTATION_TS[key] && startAt <= MUTATION_TS[key]) {\n                            dispatch({ isValidating: false });\n                            return [2 /*return*/, false];\n                        }\n                        cache.set(key, newData, false);\n                        cache.set(keyErr, undefined, false);\n                        newState = {\n                            isValidating: false\n                        };\n                        if (typeof stateRef.current.error !== 'undefined') {\n                            // we don't have an error\n                            newState.error = undefined;\n                        }\n                        if (!config.compare(stateRef.current.data, newData)) {\n                            // deep compare to avoid extra re-render\n                            // data changed\n                            newState.data = newData;\n                        }\n                        // merge the new state\n                        dispatch(newState);\n                        if (!shouldDeduping) {\n                            // also update other hooks\n                            broadcastState(key, newData, undefined);\n                        }\n                        return [3 /*break*/, 7];\n                    case 6:\n                        err_3 = _a.sent();\n                        delete CONCURRENT_PROMISES[key];\n                        delete CONCURRENT_PROMISES_TS[key];\n                        cache.set(keyErr, err_3, false);\n                        // get a new error\n                        // don't use deep equal for errors\n                        if (stateRef.current.error !== err_3) {\n                            // we keep the stale data\n                            dispatch({\n                                isValidating: false,\n                                error: err_3\n                            });\n                            if (!shouldDeduping) {\n                                // also broadcast to update other hooks\n                                broadcastState(key, undefined, err_3);\n                            }\n                        }\n                        // events and retry\n                        eventsRef.current.emit('onError', err_3, key, config);\n                        if (config.shouldRetryOnError) {\n                            retryCount = (revalidateOpts.retryCount || 0) + 1;\n                            eventsRef.current.emit('onErrorRetry', err_3, key, config, revalidate, Object.assign({ dedupe: true }, revalidateOpts, { retryCount: retryCount }));\n                        }\n                        return [3 /*break*/, 7];\n                    case 7:\n                        loading = false;\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    }, [key]);\n    // mounted (client side rendering)\n    useIsomorphicLayoutEffect(function () {\n        if (!key)\n            return undefined;\n        // after `key` updates, we need to mark it as mounted\n        unmountedRef.current = false;\n        // after the component is mounted (hydrated),\n        // we need to update the data from the cache\n        // and trigger a revalidation\n        var currentHookData = stateRef.current.data;\n        var latestKeyedData = cache.get(key) || config.initialData;\n        // update the state if the key changed (not the inital render) or cache updated\n        if (keyRef.current !== key ||\n            !config.compare(currentHookData, latestKeyedData)) {\n            dispatch({ data: latestKeyedData });\n            keyRef.current = key;\n        }\n        // revalidate with deduping\n        var softRevalidate = function () { return revalidate({ dedupe: true }); };\n        // trigger a revalidation\n        if (config.revalidateOnMount ||\n            (!config.initialData && config.revalidateOnMount === undefined)) {\n            if (typeof latestKeyedData !== 'undefined' &&\n                !IS_SERVER &&\n                window['requestIdleCallback']) {\n                // delay revalidate if there's cache\n                // to not block the rendering\n                window['requestIdleCallback'](softRevalidate);\n            }\n            else {\n                softRevalidate();\n            }\n        }\n        // whenever the window gets focused, revalidate\n        var onFocus;\n        if (config.revalidateOnFocus) {\n            // throttle: avoid being called twice from both listeners\n            // and tabs being switched quickly\n            onFocus = throttle(softRevalidate, config.focusThrottleInterval);\n            if (!FOCUS_REVALIDATORS[key]) {\n                FOCUS_REVALIDATORS[key] = [onFocus];\n            }\n            else {\n                FOCUS_REVALIDATORS[key].push(onFocus);\n            }\n        }\n        // register global cache update listener\n        var onUpdate = function (shouldRevalidate, updatedData, updatedError, dedupe) {\n            if (shouldRevalidate === void 0) { shouldRevalidate = true; }\n            if (dedupe === void 0) { dedupe = true; }\n            // update hook state\n            var newState = {};\n            var needUpdate = false;\n            if (typeof updatedData !== 'undefined' &&\n                !config.compare(stateRef.current.data, updatedData)) {\n                newState.data = updatedData;\n                needUpdate = true;\n            }\n            // always update error\n            // because it can be `undefined`\n            if (stateRef.current.error !== updatedError) {\n                newState.error = updatedError;\n                needUpdate = true;\n            }\n            if (needUpdate) {\n                dispatch(newState);\n            }\n            if (shouldRevalidate) {\n                if (dedupe) {\n                    return softRevalidate();\n                }\n                else {\n                    return revalidate();\n                }\n            }\n            return false;\n        };\n        // add updater to listeners\n        if (!CACHE_REVALIDATORS[key]) {\n            CACHE_REVALIDATORS[key] = [onUpdate];\n        }\n        else {\n            CACHE_REVALIDATORS[key].push(onUpdate);\n        }\n        // set up reconnecting when the browser regains network connection\n        var reconnect = null;\n        if (!IS_SERVER && window.addEventListener && config.revalidateOnReconnect) {\n            window.addEventListener('online', (reconnect = softRevalidate));\n        }\n        return function () {\n            // cleanup\n            dispatch = function () { return null; };\n            // mark it as unmounted\n            unmountedRef.current = true;\n            if (onFocus && FOCUS_REVALIDATORS[key]) {\n                var revalidators = FOCUS_REVALIDATORS[key];\n                var index = revalidators.indexOf(onFocus);\n                if (index >= 0) {\n                    // 10x faster than splice\n                    // https://jsperf.com/array-remove-by-index\n                    revalidators[index] = revalidators[revalidators.length - 1];\n                    revalidators.pop();\n                }\n            }\n            if (CACHE_REVALIDATORS[key]) {\n                var revalidators = CACHE_REVALIDATORS[key];\n                var index = revalidators.indexOf(onUpdate);\n                if (index >= 0) {\n                    revalidators[index] = revalidators[revalidators.length - 1];\n                    revalidators.pop();\n                }\n            }\n            if (!IS_SERVER && window.removeEventListener && reconnect !== null) {\n                window.removeEventListener('online', reconnect);\n            }\n        };\n    }, [key, revalidate]);\n    // set up polling\n    useIsomorphicLayoutEffect(function () {\n        var timer = null;\n        var tick = function () { return __awaiter(_this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!(!stateRef.current.error &&\n                            (config.refreshWhenHidden || isDocumentVisible()) &&\n                            (config.refreshWhenOffline || isOnline()))) return [3 /*break*/, 2];\n                        // only revalidate when the page is visible\n                        // if API request errored, we stop polling in this round\n                        // and let the error retry function handle it\n                        return [4 /*yield*/, revalidate({ dedupe: true })];\n                    case 1:\n                        // only revalidate when the page is visible\n                        // if API request errored, we stop polling in this round\n                        // and let the error retry function handle it\n                        _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        if (config.refreshInterval) {\n                            timer = setTimeout(tick, config.refreshInterval);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        }); };\n        if (config.refreshInterval) {\n            timer = setTimeout(tick, config.refreshInterval);\n        }\n        return function () {\n            if (timer)\n                clearTimeout(timer);\n        };\n    }, [\n        config.refreshInterval,\n        config.refreshWhenHidden,\n        config.refreshWhenOffline,\n        revalidate\n    ]);\n    // suspense\n    if (config.suspense) {\n        // in suspense mode, we can't return empty state\n        // (it should be suspended)\n        // try to get data and error from cache\n        var latestData = cache.get(key) || initialData;\n        var latestError = cache.get(keyErr) || initialError;\n        if (typeof latestData === 'undefined' &&\n            typeof latestError === 'undefined') {\n            // need to start the request if it hasn't\n            if (!CONCURRENT_PROMISES[key]) {\n                // trigger revalidate immediately\n                // to get the promise\n                revalidate();\n            }\n            if (CONCURRENT_PROMISES[key] &&\n                typeof CONCURRENT_PROMISES[key].then === 'function') {\n                // if it is a promise\n                throw CONCURRENT_PROMISES[key];\n            }\n            // it's a value, return it directly (override)\n            latestData = CONCURRENT_PROMISES[key];\n        }\n        if (typeof latestData === 'undefined' && latestError) {\n            // in suspense mode, throw error if there's no content\n            throw latestError;\n        }\n        // return the latest data / error from cache\n        // in case `key` has changed\n        return {\n            error: latestError,\n            data: latestData,\n            revalidate: revalidate,\n            mutate: boundMutate,\n            isValidating: stateRef.current.isValidating\n        };\n    }\n    // define returned state\n    // can be memorized since the state is a ref\n    return useMemo(function () {\n        var state = { revalidate: revalidate, mutate: boundMutate };\n        Object.defineProperties(state, {\n            error: {\n                // `key` might be changed in the upcoming hook re-render,\n                // but the previous state will stay\n                // so we need to match the latest key and data (fallback to `initialData`)\n                get: function () {\n                    stateDependencies.current.error = true;\n                    return keyRef.current === key ? stateRef.current.error : initialError;\n                },\n                enumerable: true\n            },\n            data: {\n                get: function () {\n                    stateDependencies.current.data = true;\n                    return keyRef.current === key ? stateRef.current.data : initialData;\n                },\n                enumerable: true\n            },\n            isValidating: {\n                get: function () {\n                    stateDependencies.current.isValidating = true;\n                    return stateRef.current.isValidating;\n                },\n                enumerable: true\n            }\n        });\n        return state;\n    }, [revalidate]);\n}\nvar SWRConfig = SWRConfigContext.Provider;\nexport { trigger, mutate, SWRConfig };\nexport default useSWR;\n","var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nimport React, { useCallback, useMemo, useState, useRef } from 'react';\nimport { cache } from './config';\n/*\nThe idea\n\nA \"Page\" component renders the content of 1 API request, it accepts an offset (in this example it's from),\nuses a SWR hook (useSWR(API + '?limit=' + limit + '&from=' + from)) and returns items (Projects).\n\nThe UI:\n      +------------------------------------------+\n      |   Projects                               |\n+------------------------------------------------------+\n|     |   +----------------+                     |     |\n|     |                                          |     |\n|     |   +------------+                         |     |\n|     |                                          |     +--> 1 Page\n|     |   +-----------------+                    |     |\n|     |                                          |     |  /projects/list?limit=4\n|     |   +---------+                            |     |\n+------------------------------------------------------+\n      |                                          |\n      |   +------------+                         |     +  /projects/list?limit=4&from=123\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |   +---------+                            |     |\n      |                                          |     |\n      |   +--------------+                       |     +\n      |                                          |\n      |   +-------------------+                  |     +  /projects/list?limit=4&from=456\n      |                                          |     |\n      |   +------------+                         |     |\n      |                                          |     |\n      |   +----------------+                     |     |\n      |                                          |     |\n      |                                          |     +\n\nThe API\n// (inside `render`)\n\nfunction App () {\n  const {\n    pages,    // an array of each page component\n    pageSWRs, // an array of SWRs of each page\n    isLoadingMore,\n    isReachingEnd,\n    isEmpty,\n    loadMore\n  } = useSWRPages(\n    'project-page', // key of this page\n\n    // ======== the actual Page component!\n    ({ offset, withSWR }) => {\n      // required: use `withSWR` to wrap your main SWR (source of your pagination API)\n      const { data } = withSWR(\n        useSWR(API + '?limit=10&from=' + offset) // request projects with offset\n      )\n      if (!data) return <Placeholder>\n      return data.projects.map(project => <Card project={project} team={team}>)\n    },\n    // ========\n\n    // a function accepts a SWR's `data`, and returns the offset of the next page (or null)\n    data => data && data.length >= 10 ? data[data.length - 1].createdAt : null,\n\n    // (optional) outside deps of your Page component. in this case it's empty\n    []\n  )\n\n  // ...\n\n  if (isEmpty) return <EmptyProjectsPage/>\n\n  return <div>\n    {pages}\n    {isReachingEnd\n      ? null\n      : <button loading={isLoadingMore} onClick={loadMore}>Load More</button>}\n  </div>\n}\n*/\nvar pageCacheMap = new Map();\nexport function useSWRPages(pageKey, pageFn, SWRToOffset, deps) {\n    if (deps === void 0) { deps = []; }\n    var pageCountKey = \"_swr_page_count_\" + pageKey;\n    var pageOffsetKey = \"_swr_page_offset_\" + pageKey;\n    var _a = useState(cache.get(pageCountKey) || 1), pageCount = _a[0], setPageCount = _a[1];\n    var _b = useState(cache.get(pageOffsetKey) || [null]), pageOffsets = _b[0], setPageOffsets = _b[1];\n    var _c = useState([]), pageSWRs = _c[0], setPageSWRs = _c[1];\n    var pageFnRef = useRef(pageFn);\n    var emptyPageRef = useRef(false);\n    // Page component (wraps `pageFn`)\n    // for performance reason we need to memorize it\n    var Page = useCallback(function (props) {\n        // render the page component\n        var dataList = pageFnRef.current(props);\n        // if dataList is [], we can assume this page is empty\n        // TODO: this API is not stable\n        if (dataList && !dataList.length) {\n            emptyPageRef.current = true;\n        }\n        else {\n            emptyPageRef.current = false;\n        }\n        return dataList;\n    }, []);\n    // Doesn't have a next page\n    var isReachingEnd = pageOffsets[pageCount] === null;\n    var isLoadingMore = pageCount === pageOffsets.length;\n    var isEmpty = isReachingEnd && pageCount === 1 && emptyPageRef.current;\n    var loadMore = useCallback(function () {\n        if (isLoadingMore || isReachingEnd)\n            return;\n        setPageCount(function (c) {\n            cache.set(pageCountKey, c + 1);\n            return c + 1;\n        });\n    }, [isLoadingMore || isReachingEnd]);\n    var _pageFn = useCallback(pageFn, deps);\n    pageFnRef.current = _pageFn;\n    var pages = useMemo(function () {\n        var getWithSWR = function (id) { return function (swr) {\n            if (!pageSWRs[id] ||\n                pageSWRs[id].data !== swr.data ||\n                pageSWRs[id].error !== swr.error ||\n                pageSWRs[id].revalidate !== swr.revalidate) {\n                // hoist side effects: setPageSWRs and setPageOffsets -- https://reactjs.org/blog/2020/02/26/react-v16.13.0.html#warnings-for-some-updates-during-render\n                setTimeout(function () {\n                    setPageSWRs(function (swrs) {\n                        var _swrs = __spreadArrays(swrs);\n                        _swrs[id] = {\n                            data: swr.data,\n                            error: swr.error,\n                            revalidate: swr.revalidate,\n                            isValidating: swr.isValidating,\n                            mutate: swr.mutate\n                        };\n                        return _swrs;\n                    });\n                    if (typeof swr.data !== 'undefined') {\n                        // set next page's offset\n                        var newPageOffset_1 = SWRToOffset(swr, id);\n                        if (pageOffsets[id + 1] !== newPageOffset_1) {\n                            setPageOffsets(function (arr) {\n                                var _arr = __spreadArrays(arr);\n                                _arr[id + 1] = newPageOffset_1;\n                                cache.set(pageOffsetKey, _arr);\n                                return _arr;\n                            });\n                        }\n                    }\n                });\n            }\n            return swr;\n        }; };\n        // render each page\n        var p = [];\n        if (!pageCacheMap.has(pageKey)) {\n            pageCacheMap.set(pageKey, []);\n        }\n        var pageCache = pageCacheMap.get(pageKey);\n        for (var i = 0; i < pageCount; ++i) {\n            if (!pageCache[i] ||\n                pageCache[i].offset !== pageOffsets[i] ||\n                pageCache[i].pageFn !== _pageFn) {\n                // when props change or at init\n                // render the page and cache it\n                pageCache[i] = {\n                    component: (React.createElement(Page, { key: \"page-\" + pageOffsets[i] + \"-\" + i, offset: pageOffsets[i], withSWR: getWithSWR(i) })),\n                    pageFn: _pageFn,\n                    offset: pageOffsets[i]\n                };\n            }\n            p.push(pageCache[i].component);\n        }\n        return p;\n    }, [_pageFn, pageCount, pageSWRs, pageOffsets, pageKey]);\n    return {\n        pages: pages,\n        pageCount: pageCount,\n        pageSWRs: pageSWRs,\n        isLoadingMore: isLoadingMore,\n        isReachingEnd: isReachingEnd,\n        isEmpty: isEmpty,\n        loadMore: loadMore\n    };\n}\n","export * from './use-swr';\nimport { default as useSWR } from './use-swr';\nexport { useSWRPages } from './use-swr-pages';\nexport { cache } from './config';\nexport default useSWR;\n","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","'use strict';\n\nvar isArray = Array.isArray;\nvar keyList = Object.keys;\nvar hasProp = Object.prototype.hasOwnProperty;\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    var arrA = isArray(a)\n      , arrB = isArray(b)\n      , i\n      , length\n      , key;\n\n    if (arrA && arrB) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n    if (arrA != arrB) return false;\n\n    var dateA = a instanceof Date\n      , dateB = b instanceof Date;\n    if (dateA != dateB) return false;\n    if (dateA && dateB) return a.getTime() == b.getTime();\n\n    var regexpA = a instanceof RegExp\n      , regexpB = b instanceof RegExp;\n    if (regexpA != regexpB) return false;\n    if (regexpA && regexpB) return a.toString() == b.toString();\n\n    var keys = keyList(a);\n    length = keys.length;\n\n    if (length !== keyList(b).length)\n      return false;\n\n    for (i = length; i-- !== 0;)\n      if (!hasProp.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      key = keys[i];\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a!==a && b!==b;\n};\n","/* eslint-disable */\nimport { useEffect, useState } from 'react';\nimport { isClient } from './util';\nvar useSessionStorage = function (key, initialValue, raw) {\n    if (!isClient) {\n        return [initialValue, function () { }];\n    }\n    var _a = useState(function () {\n        try {\n            var sessionStorageValue = sessionStorage.getItem(key);\n            if (typeof sessionStorageValue !== 'string') {\n                sessionStorage.setItem(key, raw ? String(initialValue) : JSON.stringify(initialValue));\n                return initialValue;\n            }\n            else {\n                return raw ? sessionStorageValue : JSON.parse(sessionStorageValue || 'null');\n            }\n        }\n        catch (_a) {\n            // If user is in private mode or has storage restriction\n            // sessionStorage can throw. JSON.parse and JSON.stringify\n            // cat throw, too.\n            return initialValue;\n        }\n    }), state = _a[0], setState = _a[1];\n    useEffect(function () {\n        try {\n            var serializedState = raw ? String(state) : JSON.stringify(state);\n            sessionStorage.setItem(key, serializedState);\n        }\n        catch (_a) {\n            // If user is in private mode or has storage restriction\n            // sessionStorage can throw. Also JSON.stringify can throw.\n        }\n    });\n    return [state, setState];\n};\nexport default useSessionStorage;\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t19: \"plugin not loaded\",\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t}\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtypeObject,\n\tArchtypeArray,\n\tArchtypeMap,\n\tArchtypeSet,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\treturn !proto || proto === Object.prototype\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === ArchtypeObject) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? ArchtypeArray\n\t\t: isMap(thing)\n\t\t? ArchtypeMap\n\t\t: isSet(thing)\n\t\t? ArchtypeSet\n\t\t: ArchtypeObject\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchtypeMap\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\n\telse if (t === ArchtypeSet) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return base.slice()\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\nexport function freeze(obj: any, deep: boolean): void {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tSetState,\n\tImmerScope,\n\tProxyObjectState,\n\tProxyArrayState,\n\tES5ObjectState,\n\tES5ArrayState,\n\tMapState,\n\tDRAFT_STATE\n} from \"../internal\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\n\nexport const ArchtypeObject = 0\nexport const ArchtypeArray = 1\nexport const ArchtypeMap = 2\nexport const ArchtypeSet = 3\n\nexport const ProxyTypeProxyObject = 0\nexport const ProxyTypeProxyArray = 1\nexport const ProxyTypeES5Object = 4\nexport const ProxyTypeES5Array = 5\nexport const ProxyTypeMap = 2\nexport const ProxyTypeSet = 3\n\nexport interface ImmerBaseState {\n\tparent_?: ImmerState\n\tscope_: ImmerScope\n\tmodified_: boolean\n\tfinalized_: boolean\n\tisManual_: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyTypeES5Array,\n\tProxyTypeES5Object,\n\tProxyTypeMap,\n\tProxyTypeSet,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\trootState: ImmerState,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(__DEV__ ? 18 : 19, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tplugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeMap\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeSet\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyTypeProxyObject ||\n\t\tstate.type_ === ProxyTypeProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyTypeES5Object,\n\tProxyTypeES5Array,\n\tProxyTypeSet,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE],\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumarable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// finalize all children of the copy\n\t\teach(result as any, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(state, prop: string /* strictly not, but helps TS */, value) {\n\t\tstate.assigned_[prop] = true\n\t\tif (!state.modified_) {\n\t\t\tif (is(value, peek(latest(state), prop)) && value !== undefined)\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyTypeProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\t// This is a very special case, if the prop is a getter defined by the\n\t\t// prototype, we should invoke it with the draft as context!\n\t\tif (desc) return `value` in desc ? desc.value : desc.get?.call(state.draft_)\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tisMinified,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = __DEV__ ? true /* istanbul ignore next */ : !isMinified\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tthis.produce = this.produce.bind(this)\n\t\tthis.produceWithPatches = this.produceWithPatches.bind(this)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce(base: any, recipe?: any, patchListener?: any) {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is disabled in production.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches.slice(i + 1))\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtypeMap,\n\tArchtypeSet,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === ArchtypeSet ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase ArchtypeMap:\n\t\t\treturn new Map(value)\n\t\tcase ArchtypeSet:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/* istanbul ignore next */\nfunction mini() {}\nexport const isMinified = mini.name !== \"mini\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n"],"sourceRoot":""}